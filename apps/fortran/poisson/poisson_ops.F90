!
! auto-generated by ops_fortran.py
!


















program POISSON
  use OPS_Fortran_Declarations
  use OPS_Fortran_RT_Support
  use OPS_CONSTANTS

  use, intrinsic :: ISO_C_BINDING

  implicit none

  integer logical_size_x
  integer logical_size_y
  integer ngrid_x
  integer ngrid_y
  integer n_iter

  type(ops_block), dimension(:), allocatable :: blocks

  integer S2D_00_array(2) /0,0/
  type(ops_stencil) :: S2D_00
  integer S2D_00_P10_M10_0P1_0M1_array(10) /0,0, 1,0, -1,0, 0,1, 0,-1/
  type(ops_stencil) :: S2D_00_P10_M10_0P1_0M1

  type(ops_reduction) :: red_err

  type(ops_dat) :: coordx, coordy, u, u2, f, ref

  integer d_p(2) /1,1/
  integer d_m(2) /-1,-1/

  integer base(2) /1,1/

  integer uniform_size(2)
  integer size(2)

  real(8), dimension(:), allocatable :: temp

  integer(4), dimension(:), allocatable :: sizes, disps
  integer halo_iter(2), base_from(2), base_to(2), dir(2), dir_to(2)

  integer i,j
  character(len=10) buf

  dx = 0.01_8
  dy = 0.01_8

  logical_size_x =200
  logical_size_y =200
  ngrid_x= 1
  ngrid_y= 1
  n_iter = 10000

  ALLOCATE(blocks(ngrid_x*ngrid_y))
  ALLOCATE(sizes(2*ngrid_x*ngrid_y))
  ALLOCATE(disps(2*ngrid_x*ngrid_y))



  call ops_init(2)


  DO j=1,ngrid_y
    DO i=1,ngrid_x
    write(buf,"(A5,I2,A1,I2)") "block",i," ",j
    call ops_decl_block(2, blocks(i+ngrid_x*j), buf)
    END DO
  END DO


  call ops_exit( )
end program POISSON