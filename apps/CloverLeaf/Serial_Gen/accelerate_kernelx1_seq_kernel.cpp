//
// auto-generated by ops.py on 2013-10-17 11:00
//

#include "lib.h"
//user function
#include "accelerate_kernel.h"

#ifdef _OPENMP
#include <omp.h>
#endif

// host stub function
void ops_par_loop_accelerate_kernelx1(char const *name, int dim, int* range,
 ops_arg arg0, ops_arg arg1, ops_arg arg2, ops_arg arg3,
 ops_arg arg4) {

  int  offs[5][2];
  int  count[dim];

  ops_arg args[5] = { arg0, arg1, arg2, arg3, arg4};

  #ifdef _OPENMP
    int nthreads = omp_get_max_threads( );
  #else
    int nthreads = 1;
  #endif

  int y_size = range[3]-range[2];

  #pragma omp parallel for
  for (int thr=0; thr<nthreads; thr++) {
    char **p_a[5];
    int non_gbl[5] = {0, 0, 0, 0, 0};
    int g = 0;

    for ( int i=0; i<5; i++ ){
      if (args[i].argtype == OPS_ARG_DAT) {
        p_a[i] = (char **)malloc(args[i].stencil->points * sizeof(char *));
        non_gbl[g++] = i;
      }
      else if (args[i].argtype == OPS_ARG_GBL) {
        p_a[i] = (char **)malloc(args[i].dim * sizeof(char *));
      }
    }

    int start = ((y_size-1)/nthreads+1)*thr;
    int finish = MIN(((y_size-1)/nthreads+1)*(thr+1),y_size);

    for(int n_y=start; n_y<finish; n_y++) {
      for (int n_x = range[0]; n_x < range[1]; n_x++) {
        ops_args_set(n_x, n_y, 5, args, p_a);
        accelerate_kernelx1( (double **)p_a[0], (double ** )p_a[1],
          (double ** )p_a[2], ( double **)p_a[3], (double ** )p_a[4] );
      }
    }

    for ( int i=0; i<5; i++ ){
      free(p_a[i]);
    }
  }
}
