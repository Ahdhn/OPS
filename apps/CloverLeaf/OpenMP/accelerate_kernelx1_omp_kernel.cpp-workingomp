//
// auto-generated by ops.py on 2013-10-17 11:00
//

#include "lib.h"
//user function
#include "accelerate_kernel.h"

#ifdef _OPENMP
#include <omp.h>
#endif

// host stub function
void ops_par_loop_accelerate_kernelx1(char const *name, int dim, int* range,
 ops_arg arg0, ops_arg arg1, ops_arg arg2, ops_arg arg3,
 ops_arg arg4) {

  ops_arg args[5] = { arg0, arg1, arg2, arg3, arg4};

  int  offs[5][2];

  for(int i=0; i<5; i++) {
    if (args[i].stencil!=NULL) {
      offs[i][0] = 1;  //unit step in x dimension
      offs[i][1] = ops_offs_set(range[0],range[2]+1, args[i]) - ops_offs_set(range[1],range[2], args[i]);// +1;

      if (args[i].stencil->stride[0] == 0) { //stride in y as x stride is 0
        offs[i][0] = 0;
        offs[i][1] = args[i].dat->block_size[0];
      }
      else if (args[i].stencil->stride[1] == 0) {//stride in x as y stride is 0
        offs[i][0] = 1;
        offs[i][1] = -( range[1] - range[0] );// +1;
      }
    }
  }

  #ifdef _OPENMP
    int nthreads = omp_get_max_threads( );
  #else
    int nthreads = 1;
  #endif

  int y_size = range[3]-range[2];

  #pragma omp parallel for
  for (int thr=0; thr<nthreads; thr++) {

    char **p_a[5];
    int non_gbl[5] = {0, 0, 0, 0, 0};
    int g = 0;

    for ( int i=0; i<5; i++ ){
      if (args[i].argtype == OPS_ARG_DAT) {
        p_a[i] = (char **)malloc(args[i].stencil->points * sizeof(char *));
        non_gbl[g++] = i;
      }
      else if (args[i].argtype == OPS_ARG_GBL) {
        p_a[i] = (char **)malloc(args[i].dim * sizeof(char *));
      }
    }

    int start = ((y_size-1)/nthreads+1)*thr;
    int finish = MIN(((y_size-1)/nthreads+1)*(thr+1),y_size);

    ops_args_set(range[0], start, 5, args, p_a);

    for(int n_y=start; n_y<finish; n_y++) {
      for (int n_x = range[0]; n_x < range[1]; n_x++) {

        accelerate_kernelx1( (double **)p_a[0], (double ** )p_a[1],
          (double ** )p_a[2], ( double **)p_a[3], (double ** )p_a[4] );

        for (int np=0; np<args[0].stencil->points; np++) p_a[0][np] += (args[0].dat->size * offs[0][0]);
        for (int np=0; np<args[1].stencil->points; np++) p_a[1][np] += (args[1].dat->size * offs[1][0]);
        for (int np=0; np<args[2].stencil->points; np++) p_a[2][np] += (args[2].dat->size * offs[2][0]);
        for (int np=0; np<args[3].stencil->points; np++) p_a[3][np] += (args[3].dat->size * offs[3][0]);
        for (int np=0; np<args[4].stencil->points; np++) p_a[4][np] += (args[4].dat->size * offs[4][0]);

      }
      for (int np=0; np<args[0].stencil->points; np++) p_a[0][np] += (args[0].dat->size * offs[0][1]);
      for (int np=0; np<args[1].stencil->points; np++) p_a[1][np] += (args[1].dat->size * offs[1][1]);
      for (int np=0; np<args[2].stencil->points; np++) p_a[2][np] += (args[2].dat->size * offs[2][1]);
      for (int np=0; np<args[3].stencil->points; np++) p_a[3][np] += (args[3].dat->size * offs[3][1]);
      for (int np=0; np<args[4].stencil->points; np++) p_a[4][np] += (args[4].dat->size * offs[4][1]);
    }

    for ( int i=0; i<5; i++ ){
      free(p_a[i]);
    }
  }
}
