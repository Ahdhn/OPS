\documentclass[11pt]{article}
\usepackage[colorlinks,urlcolor=blue,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{graphicx}
% \usepackage[footnotesize]{subfigure}
\usepackage{listings}
\usepackage{verbments}

\usepackage[utf8]{inputenc}
\usepackage[colorlinks,urlcolor=blue,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{url}
\usepackage{amsmath}
\usepackage{url}
\usepackage{listings}
\usepackage{verbatim}
\usepackage[top=2.1cm, bottom=2.1cm, left=2.5cm, right=2.5cm]{geometry}

\date{Aug 2014}

 \topmargin 0.in  \headheight 0pt  \headsep 0pt  \raggedbottom
 \oddsidemargin 0.1in
 \textheight 9.25in  \textwidth 6.00in
 \parskip 5pt plus 1pt minus 1pt
 \def \baselinestretch {1.25}   % one-and-a-half spaced
 \setlength {\unitlength} {0.75in}

\newenvironment{routine}[2]
{\vspace{.0in}{\noindent\bf\hspace{-5pt}  #1}{\\ \noindent #2}
\begin{list}{}{
\renewcommand{\makelabel}[1]{{\tt  ##1 } \hfil}
\itemsep 0pt plus 1pt minus 1pt
\leftmargin  1.5in
\rightmargin 0.0in
\labelwidth  1.1in
\itemindent  0.0in
\listparindent  0.0in
\labelsep    0.05in}
}{\end{list}}
%

\begin{document}

\title{OPS Distributed Memory Parallelization \\Developer Documentation}
\author{Mike Giles, Gihan Mudalige, Istvan Reguly}
\maketitle

\newpage


\tableofcontents


\newpage
\section{Introduction}


OPS is a high-level framework with associated libraries and preprocessors to generate parallel executables for
applications on \textbf{multi-block structured grids}. Multi-block structured grids can be viewed as an unstructured
collection of structured meshes/grids. In this document, we detail the initial design and implementation of the
distributed memory parallelization (based on MPI) in OPS. Many of the design decision in the library structure follows
that of the OP2 high-level library for unstructured mesh applications~\cite{op2}. However the structured mesh domain is
distinct from the unstructured mesh applications domain due to the implicit connectivity between neighbouring mesh
elements (such as vertices, cells) in structured meshes/grids. Operations involve looping over a ``rectangular''
multi-dimensional set of grid points using one or more ``stencils'' to access data.

A key aspect of an OPS application is that it can be developed purely from a traditional sequential execution point of
view and the developer need not consider any platform specific parallelization. The multi-core (OpenMP) and
many-core (CUDA, OpenACC, OpenCL) parallelizations are single (shared memory) node implementations. These
parallelizations are fine-grained. However, the size of the problem that can be solved on a single node is limited by
its compute and main-memory capacity. The compute capacity is important to solve a problem within an acceptable time to
solution. The many-core parallelizations, such as CUDA are even more restricted on a single GPU's global memory
capacity. Thus it is essential to have a distributed memory based parallel implementation to solve large problems
without being limited by the resources on a single CPU or GPU node. The idea then is to layer the more coarse grained
distributed memory parallelization on top of the thread level parallelization so that both can be utilized.

In OPS we assume that distributed memory parallelism is implemented across nodes where a node can be a single CPU core,
a multi-core CPU (or a SMP node) or a single GPU. Each MPI process will have the same application program executed (i.e.
the SPMD execution style). The message passing interface (MPI) is used in the implementation.

\section{Single-Block Design}

The first part of this developer documentation will focus on the currently implemented MPI parallelization for single
block structured meshes. When the problem only consists of a single structured mesh, under a distributed memory
parallelization, it is partitioned among a number of MPI tasks (i.e. MPI processes) and import/export halos are
constructed on each to communicate partition boundary data between MPI tasks. Thus the starting-point of a distributed
memory implementation is the design of how the \texttt{ops\_block}s, \texttt{ops\_dat}s and other data structures are
distributed among the MPI processes.

To illustrate OPS's design, as an example consider the single block structured mesh problem declared in \figurename{
\ref{fig/clover-problem}}, taken from the Cloverleaf mini-application~\cite{ops-cloverleaf}. In this case the
application is a 2D application and the application developer declares a single structured mesh with the
\texttt{ops\_decl\_block} call and then declares a number of data fields on this block with \texttt{ops\_decl\_dat}.
After declaring all the fields used in the computation over this mesh, the developer can indicate to OPS with
\texttt{ops\_partition(..)}, to partition the currently declared \texttt{ops\_dats} on the available number of MPI
processes (i.e. the \texttt{MPI\_COMM\_WORLD} universe). This call will compute the necessary sub-mesh sizes calculating
which portion of the global mesh data is to be held on each MPI process and create a Cartesian coordinate system-based
MPI universe for the given block. Of course, for any non-MPI parallelizations, \texttt{ops\_partition(..)} simply points
to a dummy sequential routine that has no effect.

% logic used in ops_partition ...

For applications such as CloverLeaf which initializes the data arrays used in the application, simply passing NULL
pointers as in \figurename{~\ref{fig/API}} will indicate to allocate \texttt{ops\_dat}s with empty data arrays. If, on
the other hand the problem has initial data to be set at the start of the program execution, OPS will provide HDF5 based
parallel I/O routines to read in the data from HDF5 files, using the dimension sizes computed for the \texttt{ops\_dat}
during \texttt{ops\_partition(..)}. For example, OPS will define a \texttt{ops\_decl\_dat\_hdf5} similar to
\texttt{ops\_decl\_dat} but with \texttt{dat} replaced by the file from which the data is read using a keyword
\texttt{name}. \\



\section{Multi-Block Design}



\begin{thebibliography}{1}
\bibitem{op2} OP2 for Many-Core Platforms, 2013. \url{http://www.oerc.ox.ac.uk/projects/op2}
\end{thebibliography}

\end{document}





